import numpy

class Hexgrid:
    '''Hexagonal grid for board management'''
    def __init__(self,size_x,size_y):
        '''Creates centre coordinates of the hexagonal grids. Center of bottom left hex is 0,0. All hexes have a diameter of 2. size_y
         is rounded up to an even number. The hex coordinates are generated by staggering the x-coordinates of the even y-coordinates. The staggers are generated by
         repeating a [0,1] vector and reshaping. To make this work correctly, we need to add an even number of y-coordinates during the
         coordinate calculations. '''

        print('Initializing board of ' + str(size_x) + ' by ' + str(size_y) + ' hexes.')

        self.size_y = int(2 * numpy.ceil(size_y / 2))  # The size of the board in y-direction is constrained to even numbers. This makes generating the grid easier and it really makes to difference to the game.
        self.size_x = size_x
        self.n_hexes = size_y * size_x                  # Number of tiles on the board
        self.tiles = list([''] * self.n_hexes)          # List with labels containing the tile type for each hex.
        self.objects = list([None] * self.n_hexes)      # List of objects (guys, boats) on the grid
        self.objects_init = list([''] * self.n_hexes)   # List of names of the objects on the board during init.
        self.selected = []                              # Index of the hex containing the currently selected pawn . Passing this index handles most game functionality.
        self.select_reachable = numpy.array([])         # Index list of the hexes reachable for the currently selected pawn.

        ''' Generate the y-coordinates by repeating the y_coordinates 'size_x' times and transposing to x-first matrix orientation.
        NB, the hex centers in y direction are in reality 0.75 apart. To mame things easier, I account for this in the visualizer.'''
        self.y_coords = numpy.array(list(range(0, 2 * size_y, 2)) * size_x).reshape(size_x, size_y).transpose().ravel()
        ''' The x-coordinates for the even y-coordinates need to be staggered by half a hex. We generate this by repeating [0,1]
        x*y_rounded times, turning it into a mateix, transposing it and turning it into an array.'''
        x_stagger = numpy.array(list(range(0, 2)) * int(self.n_hexes / 2))
        x_stagger = x_stagger.reshape(size_x, size_y).transpose().ravel()

        # The stagger values (0 or 1) are added to an array containing x coordinates (0-size_x repeated size_y times).
        self.x_coords = numpy.add(numpy.array(list(range(0, 2 * size_x, 2)) * size_y), + x_stagger)

        # The hexes at the edges and corners of the board have less than 6 connections and need to handled separately/
        north = numpy.array(range(1, size_x - 1, 1))
        west = numpy.array(range(size_x, size_x * (size_y - 1), size_x))
        south = numpy.array(range(size_x * (size_y - 1) + 1, self.n_hexes - 1, 1))
        east = numpy.array(range(2 * size_x - 1, size_x * (size_y - 1), size_x))

        north_west = 0
        north_east = size_x - 1
        south_west = size_x * (size_y - 1)
        south_east = self.n_hexes - 1

        # List of all hexes
        self.all_hexes = numpy.array(range(0, self.n_hexes))

        # For assigning the oblique connections we need to distinguish between even and uneven rows.
        odd_rows = self.all_hexes[numpy.in1d(self.y_coords, numpy.array(range(0, size_y * 2, 4)))]
        even_rows = self.all_hexes[numpy.in1d(self.y_coords, numpy.array(range(2, size_y * 2, 4)))]

        # Now we determine which hexes are not at the edges by concatenating all edges...
        edge = numpy.concatenate([south, east, west, north, [south_east, south_west, north_east, north_west]])
        # ...and removing them from a list of all hexes on the grid.
        inside = numpy.setdiff1d(self.all_hexes, edge)

        ''' Now we need to process each of the six connectivity directions separately by listing the hex indices for which the direction applies.
        The connections are stored in a matrix, where the rows identify the hex of origin and the rows the destination.

        For the connectivity matrix, it kind of makes sense to use booleans, but that seems
        to make the matrix multiplications in we do to get n-step connections a lot slower. Maybe they're cast to numericals?
        Anyway, I'm not using booleans because it's slow. '''
        self.all_conn_1 = numpy.zeros((self.n_hexes, self.n_hexes))  # Initialize the connectivity matrix with zeros.
        select = numpy.concatenate([inside, west, south, north, [south_west, north_west]])  # Connections to the east
        self.all_conn_1[(select), (select) + 1] = 1

        select = numpy.concatenate([inside, east, south, north, [south_east, north_east]])  # Connections to the west
        self.all_conn_1[(select), (select) - 1] = 1

        select = numpy.intersect1d(numpy.concatenate([inside, east, south]), odd_rows)  # north-west connections, odd row numbers.
        self.all_conn_1[(select), (select) - size_x - 1] = 1
        select = numpy.intersect1d(numpy.concatenate([inside, east, south, west, [south_west, south_east]]), even_rows)  # north-west connections, even row numbers.
        self.all_conn_1[(select), (select) - size_x] = 1

        select = numpy.intersect1d(numpy.concatenate([inside, west, north, east, [north_west, north_east]]), odd_rows)  # Connections to the south-east, odd rows
        self.all_conn_1[(select), (select) + size_x] = 1
        select = numpy.intersect1d(numpy.concatenate([inside, west, north]), even_rows)  # Connections to the south-east, even rows
        self.all_conn_1[(select), (select) + size_x + 1] = 1

        select = numpy.intersect1d(numpy.concatenate([inside, west, east, south]), odd_rows)  # Connections to the north-east, odd rows
        self.all_conn_1[(select), (select) - size_x] = 1
        select = numpy.intersect1d(numpy.concatenate([inside, west, south, [south_west]]), even_rows)  # Connections to the north-east, even rows
        self.all_conn_1[(select), (select) - size_x + 1] = 1

        select = numpy.intersect1d(numpy.concatenate([inside, north, east, [north_east]]), odd_rows)  # Connections to the south-west, odd rows
        self.all_conn_1[(select), (select) + size_x - 1] = 1
        select = numpy.intersect1d(numpy.concatenate([inside, north, east, west]), even_rows)  # Connections to the south-west, even rows
        self.all_conn_1[(select), (select) + size_x] = 1

    def get_connections(self,index_list,conn_list_name,dist):
        ''' Returns all hex indices of tiles which are dist away from all hexes in index_list according to connectivity matrix conn_list_name'''
        # Check if the list of connections has been extended far enough to fulfill the request. If not then add it.
        try:
            print('Retrieving connections ' + conn_list_name + '_' + str(dist))
            connections = getattr(self, conn_list_name + '_' + str(dist))

        except AttributeError:
            print('Generating ' + str(dist) + '-step connectivity matrix for ' + conn_list_name)
            ''' Retrieve the dist-min-1-step connectivity for conn_list_name. 
            If this isn't found, it is created by running this function recursively.'''
            try:
                connection_dist_min_one = getattr(self, conn_list_name + '_' + str(dist-1))
            except AttributeError:
                self.get_connections(index_list,conn_list_name,dist-1)
                connection_dist_min_one = getattr(self, conn_list_name + '_' + str(dist - 1))

            ''' Somehow, if we just exponate the connectivities which have narrow bridges, there are steps missing. 
            We fix this by multipling dist-min-one connectivity with the full connectivity and then removing the 
            rows and columns of the unreachable hexes according to the original connectivity matrix of dist-min-one.'''
            all_conn_1 = getattr(self,'all_conn_1')       # Get the connectivity for all hexes
            connections = numpy.add(numpy.dot(connection_dist_min_one,all_conn_1),connection_dist_min_one)  # Calculate the dist-steps connectivity
            remove = numpy.where(sum(connection_dist_min_one) == 0)
            connections[remove,:] = 0
            connections[:,remove] = 0
            setattr(self,conn_list_name + '_' + str(dist), connections)       # Store the new connectivity matrix because we will probably need it again

        # Return indices to the columns which contain a number for any of the rows in Index_list, excluding the hexes in index_list themselves
        return numpy.setdiff1d(numpy.where(connections[index_list,:].sum(0)>0), index_list)

    def grow_land(self, number, tile_file):
        ''' Put the land tiles in a stack and shuffle'''
        self.tile_draw = DrawPile(tile_file, 'tile_drawpile')

        '''Generates an island of "number" land tiles starting from a random hex.'''
        # Randomly pick starting hex and set the tile
        this_index = numpy.random.randint(0, self.n_hexes - 1)
        drawn_tile = self.tile_draw.lose_card()
        print('Land tile ' + drawn_tile.name + ' added to hex ' + str(this_index))
        self.tiles[this_index] = drawn_tile.name
        index_list = [this_index]
        # Add the remaining tiles to the start hex
        for i in range(1, number):
            # Retrieve the neighboring hexes of the already placed land tiles
            neighbours = self.get_connections(index_list, 'all_conn', 1)
            # Select a random hex from the neighbours
            this_index = neighbours[numpy.random.randint(0, len(neighbours))]
            drawn_tile = self.tile_draw.lose_card()
            print('Land tile ' + drawn_tile.name + ' added to hex ' + str(this_index))

            # Add a land tile label to the tiles list
            self.tiles[this_index] = drawn_tile.name
            # Add the new index to the index_list for use in the next iterations
            index_list.append(this_index)

        self.set_land_connectivity()

    def set_land_connectivity(self):
        # To get the connectivity matrix for the landmass, we copy the full board connectivity and set the not-land rows and columns to 0
        self.land_conn_1 = numpy.array(self.all_conn_1)                     # Copy the full connectivity, using '=' creates a link instead of a copy!
        not_land = [i for i, x in enumerate(self.tiles) if x in ['water','home']]
        self.land_conn_1[not_land, :] = 0
        self.land_conn_1[:, not_land] = 0

    def set_water_connectivity(self):
        # Set the connectivity matrix for water
        self.water_conn_1 = numpy.array(self.all_conn_1)
        not_water = [i for i, x in enumerate(self.tiles) if x not in ['water']]
        self.water_conn_1[not_water, :] = 0
        self.water_conn_1[:, not_water] = 0